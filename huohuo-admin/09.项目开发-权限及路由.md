# 权限

## 登录验证

后台项目区别于其他项目的一大特点，就是权限验证及其安全性。我们开发时一般做的第一个页面，就是登录页面，它们是息息相关的。

用户输入用户名和密码后，首先通过前端的输入格式和验证工具进行验证，验证成功后，再`login`到服务端验证此用户是否存在及密码是否正确。验证成功后，服务端会返回一个`token`和用户信息，它们会被存到`sessionStorage`中，作为与后端数据交互的权限标识。

### 前端验证

一般验证方式：

- 输入格式验证
- 验证工具：短信验证码、字符验证码、滑块图、文案编辑等

本项目暂时没有使用以上验证方式，但在后续计划中 ~

### 后端验证

- 一般通过数据库校验进行登录验证
- 通过用户角色信息进行权限控制

## 权限使用

通过上面的讲述，我们可以知道这里的权限控制有两种，登录权限（是否能成功登录）和角色权限（角色信息如菜单路由、操作按钮权限）。来看看具体是如何实现的吧！

上面我们已经详细讲过权限中有关角色路由表的内容，这里我们再看看更细粒化的按钮权限。

通常我们会以角色来做权限判定标准，执行可许的权限操作。

### 权限路由控制

首先我们来分析，通过权限，有哪些方式可以控制路由。

#### 思路一

纯后端动态控制路由表，前端写好页面及其路由

```typescript
const routes = [
  {
    path: "/test",
    component: () => import("/@/views/test/test.vue"),
  },
];
```

登录后，根据用户的权限，路由表（含所有路由配置项）全部从后端一次性获取

```js
{
    path: "/test",
    name: "test",
    redirect: "/test/test",
    meta: {
        title: "test",
        icon: "test_icon",
        i18n: true,
        showLink: true,
        rank: 100
	},
	children: {...}
}
```

#### 思路二

前端控制页面级权限：拿到后端用户返回的角色`role`，映射出前端写好的路由表控制当前角色能够看到的页面（如菜单栏）

前端写好页面及所有路由表

```typescript
const routes =[
	{
	path: '/test',
    name: "test",
    component: () => import('/@/views/test/test.vue')
    meta: {
        title: "test",
        icon: "test_icon",
        roles: ['admin', 'test'] // 用户角色符合该配置项，则将该路由添加进最终路由表
	},
	children: {...}
	}
]
```

后端控制请求权限：用户向服务端发送请求头携带`token`的请求，服务端根据用户角色来验证是否有该操作的权限

#### 思路三

通过`info`获取到`role`，再从后端动态地根据`role`拿到权限相关的信息（如动态路由表、按钮权限），将通过权限过滤出来的动态路由表，与前端写好的静态路由表结合，生成最终路由表。

本项目采用思路三的方式开发的原因：

- 静态路由与动态路由区分开
- 通过用户角色过滤动态路由表，菜单栏由路由表动态生成
- 权限相对灵活，后端对角色权限的改动，前端不需要跟着改动

#### 简单实现

登录的成功后，我们做了一个初始化路由操作，传入用户角色的参数，目的就是拿到一份对应角色的动态路由表，也就是权限的过滤。

```typescript
// src/views/login.vue
const onLogin = (): void => {
  storageSession.setItem("info", {
    username: "admin",
    accessToken: "eyJhbGciOiJIUzUxMiJ9.test",
  });
  initRouter("admin").then(() => {}); // 初始化路由
  router.push("/");
};
```

这份后端传过来的动态路由表（`permissionRouter`），我们在`mock`（mock/asyncRoutes.ts）中模拟出来，后端同样是根据用户角色参数来返回正确的动态路由信息。

```typescript
export default [
  {
    url: "/getAsyncRoutes",
    method: "get",
    response: ({ query }) => {
      if (query.name === "admin") {
        // 不同角色返回不同的路由信息
        return {
          code: 0,
          info: [setDifAuthority("v-admin", permissionRouter)],
        };
      } else {
        return {
          code: 0,
          info: [setDifAuthority("v-test", permissionRouter)],
        };
      }
    },
  },
] as MockMethod[];
```

### 直接使用用户信息

这里我们以权限界面的一个简单角色切换功能为例分析（src/views/permisson/page/index）：

```typescript
import { storageSession } from "/@/utils/storage"; // 拿到用户的 info

let purview = ref<string>(storageSession.getItem("info").username); // 获取用户角色（username）

function changRole() {
  if (unref(purview) === "admin") {
    // 是 admin，则有权限作如下操作
    storageSession.setItem("info", {
      username: "test",
      accessToken: "eyJhbGciOiJIUzUxMiJ9.test",
    });
    window.location.reload();
  } else {
    storageSession.setItem("info", {
      username: "admin",
      accessToken: "eyJhbGciOiJIUzUxMiJ9.admin",
    });
    window.location.reload();
  }
}
```

### 使用角色指令

`auth`指令

```typescript
// src/directives/permission/index.ts
export const auth: Directive = {
  mounted(el: HTMLElement, binding: DirectiveBinding) {
    const { value } = binding;
    if (value) {
      const authRoles = value;
      const hasAuth = usePermissionStoreHook().buttonAuth.includes(authRoles);
      if (!hasAuth) {
        el.parentNode.removeChild(el);
      }
    } else {
      throw new Error("need roles! Like v-auth=\"['admin','test']\"");
    }
  },
};
```

指令可以帮助我们像使用 v-model 一样，快速的达到想要的效果，比如做角色判定（src/views/permisson/button.index.vue）。

```html
<script setup lang="ts">
  const auth = ref<boolean>(storageSession.getItem("info").username || "admin"); // 拿到用户角色
  ......
</script>

<template>
  <div>
    <el-radio-group v-model="auth" @change="changRole">
      <el-radio-button label="admin"></el-radio-button>
      <el-radio-button label="test"></el-radio-button>
    </el-radio-group>
    <!-- 绑定 auth 指令，不同指令参数显示不同标签 -->
    <p v-auth="'v-admin'">只有admin可看</p>
    <p v-auth="'v-test'">只有test可看</p>
  </div>
</template>
```

# 路由

## 结构设计

来看看我们简化的路由文件结构，主要由路由总入口`index.ts`和 路由模块`modules`组成。

![image-20220106154132116](https://pictures-1312013355.cos.ap-guangzhou.myqcloud.com/pictures/202201061541165.png)

这样的结构在大型项目里非常常见，modules 里面的每个文件代表一个路由模块，每个路由模块对应各自相同的功能页面，这样就非常利于项目的维护。

```
├── modules
│   ├── error.ts                         # 错误页面
│   ├── externalLink.ts                  # 外链页面
│   ├── home.ts                          # 主页面
│   └── remaining.ts                     # 剩余页面（如登录页面、重定向页面）
......
```

## 路由配置项

举例列出本项目可能用到的配置选项

```js
const routes = {
  path: "/", // 路由地址
  name: "test", // 路由名（对应，不要重复）
  component: Layout, // Layout 组件，一般不用动（如需整体空白页面，请去掉）
  redirect: "/redirect", // 路由重定向
  meta: {
    title: "测试", // 菜单名称（兼容国际化、非国际化，非国际化的话可以直接 title 写中文，i18n 可写 false，也可直接不加 i18n 字段）
    icon: "icon", // 菜单图标（只针对顶级路由，也就是与当前 meta 平级的 component 为 Layout 的路由）
    i18n: true, // 国际化（开启 true、关闭 false）
    showLink: true, // 是否在菜单中显示
    rank: 9 // 菜单升序排序，值越高排的越后（只针对顶级路由，也就是与当前 meta 平级的 component 为 Layout 的路由）
  },
  children: [ // 子路由配置项
    {
      path: "/error/404", // 子路由地址
      name: "404", // 路由名字（对应不要重复，根当前组件的name保持一致）
      component: () => import("/@/views/error/404.vue"), // 按需加载组件
      meta: {
        authority: ['admin'], // 路由权限设置
        keepAlive: true // 路由组件缓存（开启 true、关闭 false）
        transition: { // 页面加载动画（有两种形式，一种直接采用 vue 内置的 transitions 动画，另一种是使用 animate.css 进、离场动画）
          name: "fade", // 当前路由动画效果，参考https://next.router.vuejs.org/guide/advanced/transitions.html#transitions
          enterTransition: "animate__zoomIn", // 进场动画
          leaveTransition: "animate__zoomOut", // 离场动画
        },
        dynamicLevel: 3, // 动态路由可打开的最大数量
        refreshRedirect: "/tabs/index", // 刷新重定向（用于未开启标签页缓存，刷新页面获取不到动态title）
      }
      extraIcon: { // 菜单名称右侧的额外图标，支持fontawesome、iconfont、element-plus-icon
        svg: true,
        name: "team-icon",
      },
    },
  ]
}
```

## 路由分类

### 静态路由

**constantRoutes：** 不需要动态判断权限的路由

![image-20211124212903021](https://pictures-1312013355.cos.ap-guangzhou.myqcloud.com/pictures/202111242129053.png)

### 动态路由

**getAsyncRoutes：** 请求后端，动态判断权限返回的路由表，并通过 `addRoute` 动态添加的页面。（项目中作为开发测试，动态路由都由`mock`模拟）

先用 Mock 模拟后台，传出`/getAsyncRoutes`接口路由表数据

![image-20211125112204284](https://pictures-1312013355.cos.ap-guangzhou.myqcloud.com/pictures/202111251122326.png)

通过前端封装的 API 接口拿到路由表数据（src/api/routes.ts）

```typescript
import { http } from "../utils/http";

export const getAsyncRoutes = (data?: object) => {
  return http.request("get", "/getAsyncRoutes", { data });
};
```

将从后端拿到的路由表进行过滤，生成规范化路由，通过 `router.addRoute` 添加到最终创建的路由实例。

```typescript
// 初始化路由
const initRouter = (name: string) => {
  return new Promise((resolve) => {
    getAsyncRoutes({ name }).then(({ info }) => {
      if (info.length === 0) {
        usePermissionStoreHook().changeSetting(info);
      } else {
        formatFlatteningRoutes(addAsyncRoutes(info)).map(
          (v: RouteRecordRaw) => {
            // 防止重复添加路由
            if (
              router.options.routes[0].children.findIndex(
                (value) => value.path === v.path
              ) !== -1
            ) {
              return;
            } else {
              // 切记将路由push到routes后还需要使用addRoute，这样路由才能正常跳转
              router.options.routes[0].children.push(v);
              // 最终路由进行升序
              ascending(router.options.routes[0].children);
              if (!router.hasRoute(v?.name)) router.addRoute(v);
            }
            resolve(router);
          }
        );
        usePermissionStoreHook().changeSetting(info);
      }
      router.addRoute({
        path: "/:pathMatch(.*)",
        redirect: "/error/404",
      });
    });
  });
};
```

::: warn

这里经过了`getAsyncRoutes`接口调用，`store`中才会有路由表相关数据。所以当你去掉 mock 模拟请求，使用 http 请求后端的时候，由于调用`getAsyncRoutes`接口失败，`store`中 的路由数据将为空（默认），所以菜单栏是不会被渲染出来的。详情可以查看[菜单栏篇](pages/3c2345)

:::

## 路由封装

### 整体思路

![image-20211125115445323](https://pictures-1312013355.cos.ap-guangzhou.myqcloud.com/pictures/202111251154367.png)

### 前置处理

上面我们已经拿到了所有的静态路由表和动态路由表，我们需要将两个表进行整合，并按页面的渲染需要生成最终的路由表。

通过上一小节我们设定好的路由配置项，可以过滤出符合配置的路由表，以适应不同的路由需要。

**路由排序**

```typescript
// 按照路由中meta下的rank等级升序来排序路由
const ascending = (arr: any[]) => {
  return arr.sort(
    (a: { meta: { rank: number } }, b: { meta: { rank: number } }) => {
      return a?.meta?.rank - b?.meta?.rank;
    }
  );
};
```

**静态路由导出**

```typescript
// 将所有静态路由导出
export const constantRoutesArr: Array<RouteComponent> = ascending(
  constantRoutes
).concat(...remainingRouter);
```

**过滤渲染路由**

```typescript
// 过滤 meta 中 showLink 为 false 的路由
export const filterTree = (data) => {
  const newTree = data.filter((v) => v.meta.showLink);
  newTree.forEach((v) => v.children && (v.children = filterTree(v.children)));
  return newTree;
};
```

**过滤缓存路由**

```typescript
// 从路由中提取 keepAlive 为 true 的 name 组成数组
export const getAliveRoute = () => {
  const alivePageList = [];
  const recursiveSearch = (treeLists) => {
    if (!treeLists || !treeLists.length) {
      return;
    }
    for (let i = 0; i < treeLists.length; i++) {
      if (treeLists[i]?.meta?.keepAlive) alivePageList.push(treeLists[i].name);
      recursiveSearch(treeLists[i].children);
    }
  };
  recursiveSearch(router.options.routes);
  return alivePageList;
};
```

**缓存路由处理（批量删除、增删刷新）**

```typescript
// 批量删除缓存路由
export const delAliveRoutes = (delAliveRouteList: Array<RouteConfigs>) => {
  delAliveRouteList.forEach((route) => {
    usePermissionStoreHook().cacheOperate({
      mode: "delete",
      name: route?.name,
    });
  });
};
```

```typescript
// 处理缓存路由（添加、删除、刷新）
export const handleAliveRoute = (
  matched: RouteRecordNormalized[],
  mode?: string
) => {
  switch (mode) {
    case "add":
      matched.forEach((v) => {
        usePermissionStoreHook().cacheOperate({ mode: "add", name: v.name });
      });
      break;
    case "delete":
      usePermissionStoreHook().cacheOperate({
        mode: "delete",
        name: matched[matched.length - 1].name,
      });
      break;
    default:
      usePermissionStoreHook().cacheOperate({
        mode: "delete",
        name: matched[matched.length - 1].name,
      });
      useTimeoutFn(() => {
        matched.forEach((v) => {
          usePermissionStoreHook().cacheOperate({ mode: "add", name: v.name });
        });
      }, 100);
  }
};
```

### 路由创建

```typescript
// 创建路由实例
export const router: Router = createRouter({
  history: createWebHashHistory(), // 基于 hash 的历史记录（不需要在服务器上进行任何配置，但是 SEO 不友好）
  routes: filterTree(ascending(constantRoutes)).concat(...remainingRouter), // 初始路由表
  scrollBehavior(to, from, savedPosition) {
    // 在页面之间导航时控制滚动的函数，返回的是一个 promise
    return new Promise((resolve) => {
      if (savedPosition) {
        return savedPosition;
      } else {
        if (from.meta.saveSrollTop) {
          const top: number =
            document.documentElement.scrollTop || document.body.scrollTop;
          resolve({ left: 0, top });
        }
      }
    });
  },
});
```

创建完成后，还需要调用`initRouter`将路由表初始化

### 辅助

```typescript
// 重置路由
export function resetRouter() {
  router.getRoutes().forEach((route) => {
    const { name } = route;
    if (name) {
      router.hasRoute(name) && router.removeRoute(name);
    }
  });
}
```

```typescript
// 路由白名单
const whiteList = ["/login"];
```

### 导航守卫

```typescript
router.beforeEach((to: toRouteType, _from, next) => {
  if (to.meta?.keepAlive) {
    const newMatched = to.matched;
    handleAliveRoute(newMatched, "add");
    // 页面整体刷新和点击标签页刷新
    if (_from.name === undefined || _from.name === "redirect") {
      handleAliveRoute(newMatched);
    }
  }
  const name = storageSession.getItem("info");
  NProgress.start();
  const externalLink = to?.redirectedFrom?.fullPath;
  if (!externalLink)
    to.matched.some((item) => {
      item.meta.title
        ? (document.title = transformI18n(
            item.meta.title as string,
            item.meta?.i18n as boolean
          ))
        : "";
    });
  if (name) {
    if (_from?.name) {
      // 如果路由包含http 则是超链接 反之是普通路由
      if (externalLink && externalLink.includes("http")) {
        openLink(`http${split(externalLink, "http")[1]}`);
        NProgress.done();
      } else {
        next();
      }
    } else {
      // 刷新
      if (usePermissionStoreHook().wholeMenus.length === 0)
        initRouter(name.username).then((router: Router) => {
          if (!useMultiTagsStoreHook().getMultiTagsCache) {
            const handTag = (
              path: string,
              parentPath: string,
              name: RouteRecordName,
              meta: RouteMeta
            ): void => {
              useMultiTagsStoreHook().handleTags("push", {
                path,
                parentPath,
                name,
                meta,
              });
            };
            // 未开启标签页缓存，刷新页面重定向到顶级路由（参考标签页操作例子，只针对静态路由）
            if (to.meta?.refreshRedirect) {
              const routes = router.options.routes;
              const { refreshRedirect } = to.meta;
              const { name, meta } = findRouteByPath(refreshRedirect, routes);
              handTag(
                refreshRedirect,
                getParentPaths(refreshRedirect, routes)[1],
                name,
                meta
              );
              return router.push(refreshRedirect);
            } else {
              const { path } = to;
              const index = findIndex(remainingRouter, (v) => {
                return v.path == path;
              });
              const routes =
                index === -1
                  ? router.options.routes[0].children
                  : router.options.routes;
              const route = findRouteByPath(path, routes);
              const routePartent = getParentPaths(path, routes);
              // 未开启标签页缓存，刷新页面重定向到顶级路由（参考标签页操作例子，只针对动态路由）
              if (
                path !== routes[0].path &&
                route?.meta?.rank !== 0 &&
                routePartent.length === 0
              ) {
                const { name, meta } = findRouteByPath(
                  route.meta.refreshRedirect,
                  routes
                );
                handTag(
                  route.meta?.refreshRedirect,
                  getParentPaths(route.meta?.refreshRedirect, routes)[0],
                  name,
                  meta
                );
                return router.push(route.meta?.refreshRedirect);
              } else {
                handTag(
                  route.path,
                  routePartent[routePartent.length - 1],
                  route.name,
                  route.meta
                );
                return router.push(path);
              }
            }
          }
          router.push(to.fullPath);
        });
      next();
    }
  } else {
    if (to.path !== "/login") {
      if (whiteList.indexOf(to.path) !== -1) {
        next();
      } else {
        next({ path: "/login" });
      }
    } else {
      next();
    }
  }
});

router.afterEach(() => {
  NProgress.done();
});
```

## 其他

### 路由刷新和重定向
