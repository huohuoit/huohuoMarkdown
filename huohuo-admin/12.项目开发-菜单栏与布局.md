# 菜单栏

在上一篇，我们详细介绍了路由及路由表，根据用户的角色权限我们划分出一份份属于当前登录用户的可访问路由。而作为后台管理系统的核心部分——菜单栏，它的生成与这份可访问路由表息息相关。路由表决定了菜单选项（有哪些菜单），路由的配置项决定了菜单选项的特征（如菜单选项的标题、图标、排序等）。

## 菜单栏

目前已开发垂直侧边菜单栏和顶部水平菜单栏两种模式，后续将会迭代为更复杂的综合菜单。关于这部分的基本布局设计，已经有过详细介绍，这里我们来关注代码逻辑的开发设计。

### 整体设计思路

涉及的主要文件：`src/router/utils.ts、src/store/modules/permission.ts、src/layout/components/sidebar`

![image-20211229135726709](https://pictures-1312013355.cos.ap-guangzhou.myqcloud.com/pictures/202112291357769.png)

::: warning

上面设计的最终目的是**生成菜单栏**，需要小心的是不要与路由`router`混淆了。前者是拿到属于用户可访问的菜单路由表，以该表为基础进行菜单栏渲染。后者是拿到用户可访问的路由表，构建系统页面路由。

:::

### 实现细节

#### 用户登录

首先我们在登录界面`login.vue`进行登录操作。这里并未与实际后端接口进行交互验证，只做了模拟处理

```typescript
const onLogin = (): void => {
  ...... // 一些登录相关的验证
  storageSession.setItem("info", { // 验证成功后，将后端返回的用户信息存入 sessionstorage
    username: "admin",
    accessToken: "eyJhbGciOiJIUzUxMiJ9.test"
  });
  initRouter("admin").then(() => {}); // 根据用户（角色）信息初始化菜单路由
  router.push("/"); // 登录成功后跳转页面
};
```

#### 路由获取

处理路由的工具方法都放在`src/router/utils.ts`，这里通过`initRouter`方法进行动态路由匹配并初始化菜单路由。

```typescript
// 初始化路由(传入用户角色 name)
const initRouter = (name: string) => {
  return new Promise((resolve) => {
    // 根据角色 name 拿到后端传过来的权限路由数据(info数组)
    getAsyncRoutes({ name }).then(({ info }) => {
      // 如果拿到空路由数组
      if (info.length === 0) {
        usePermissionStoreHook().changeSetting(info); // 依然调用 store 方法生成菜单相关数据
      } else {
        // 后端路由规范化 =》 路由数组扁平化 =》 添加 info 路由到 router 上
        formatFlatteningRoutes(addAsyncRoutes(info)).map(
          (v: RouteRecordRaw) => {
            // 防止重复添加路由
            if (
              router.options.routes[0].children.findIndex(
                (value) => value.path === v.path
              ) !== -1
            ) {
              return;
            } else {
              // 切记将路由 push 到 routes 后还需要使用 addRoute，这样路由才能正常跳转
              router.options.routes[0].children.push(v);
              // 路由进行升序
              ascending(router.options.routes[0].children);
              // router.hasRoute()，检查路由是否存在，不存在就加上
              if (!router.hasRoute(v?.name)) router.addRoute(v);
            }
            resolve(router); // 返回路由地址的标准化版本
          }
        );
        usePermissionStoreHook().changeSetting(info); // 调用 store 方法生成菜单相关数据
      }
      router.addRoute({
        path: "/:pathMatch(.*)", // 捕获所有路由并将其放在 $route.params.pathMatch 下
        redirect: "/error/404", // 跳转到未知路径时，重定向到 404 页面
      });
    });
  });
};
```

::: warning

这里的`initRouter`其实只是个“中介”，实际上它只是调用了一个`Promise`，来源于`src/api/routed.ts`暴露的接口，针对`Promise`的返回值做了一些处理。

:::

#### 菜单路由状态管理

接来下进入到`store`模块，有关菜单和按钮权限的状态数据都定义在`usePermissionStore`中，通过`usePermissionStoreHook`暴露出来。

```typescript
export const usePermissionStore = defineStore({
  id: "huo-permission",
  state: () => ({
    // 静态路由生成的菜单
    constantMenus,
    // 整体路由生成的菜单（静态、动态）
    wholeMenus: [],
  }),
  actions: {
    // 获取异步路由菜单
    asyncActionRoutes(routes) {
      if (this.wholeMenus.length > 0) return;
      this.wholeMenus = filterTree(
        ascending(this.constantMenus.concat(routes))
      );
    },
    async changeSetting(routes) {
      await this.asyncActionRoutes(routes);
    },
  },
});
```

#### 菜单栏渲染

这里以侧边垂直菜单栏`vertical`为例（顶部水平菜单栏菜单部分一样）。

![image-20211230094756924](https://pictures-1312013355.cos.ap-guangzhou.myqcloud.com/pictures/202112300947147.png)

#### 生成菜单栏

示例

![image-20211230144523637](https://pictures-1312013355.cos.ap-guangzhou.myqcloud.com/pictures/202112301445671.png)
