# 菜单栏

在上一篇，我们详细介绍了路由及路由表，根据用户的角色权限我们划分出一份份属于当前登录用户的可访问路由。而作为后台管理系统的核心部分——菜单栏，它的生成与这份可访问路由表息息相关。路由表决定了菜单选项（有哪些菜单），路由的配置项决定了菜单选项的特征（如菜单选项的标题、图标、排序等）。

## 菜单栏的生成

在上篇，我们说到了路由表的生成，核心就是 initRouter 方法，这里我们再给出：

```typescript
// 初始化路由 src\router\utils.ts
function initRouter(name: string) {
  return new Promise((resolve) => {
    getAsyncRoutes({ name }).then(({ info }) => {
      if (info.length === 0) {
        usePermissionStoreHook().changeSetting(info);
      } else {
        // 过滤后端传来的动态路由 重新生成规范路由。并将多级嵌套路由处理成一维数组
        formatFlatteningRoutes(addAsyncRoutes(info)).map(
          (v: RouteRecordRaw) => {
            // 防止重复添加路由
            if (
              router.options.routes[0].children.findIndex(
                (value) => value.path === v.path
              ) !== -1
            ) {
              return;
            } else {
              // 切记将路由push到routes后还需要使用addRoute，这样路由才能正常跳转
              router.options.routes[0].children.push(v);
              // 最终路由进行升序
              ascending(router.options.routes[0].children);
              if (!router.hasRoute(v?.name)) router.addRoute(v);
              const flattenRouters = router
                .getRoutes()
                .find((n) => n.path === "/");
              router.addRoute(flattenRouters);
            }
            resolve(router);
          }
        );
        usePermissionStoreHook().changeSetting(info);
      }
      router.addRoute({
        path: "/:pathMatch(.*)",
        redirect: "/error/404",
      });
    });
  });
}
```

initRouter 返回一个 Promise，这个 Promise 的成功返回由一个请求接口 getAsyncRoutes 包裹。也就是说，这里必须有一个后端接口的支持，并且返回合适的 info（参考 mock 的路由表），才会顺利执行后面的代码，否则你可能会发现，成功登录后跳转的页面不会出现菜单栏。

> 而项目的菜单栏是在哪里控制的呢？

### usePermissionStoreHook

在 src\store\modules\permission.ts 文件中，封装了权限相关的数据 hook。想快速知道这个 hook 是为什么服务的（也就是管理哪些数据的状态），我们可以从 state 选项入手：

```js
  state: () => ({
    // 静态路由生成的菜单
    constantMenus,
    // 整体路由生成的菜单（静态、动态）
    wholeMenus: [],
    // 深拷贝一个菜单树，与导航菜单不突出
    menusTree: [],
    buttonAuth: [],
    // 缓存页面keepAlive
    cachePageList: []
  }),
```

可以一目了然，在这里，存放了我们页面的菜单及相关的配置。所以说，语义化的命名和必要的注释是一份优秀代码必不可少的部分。

然后我们在 initRouter 中调用了该 hook 下的 action，也就是 changeSetting 方法，将路由表与菜单正式衔接起来，这样我们的页面就会有菜单栏啦！

![image-20220609181740209](https://pictures-1312013355.cos.ap-guangzhou.myqcloud.com/pictures/202206091817274.png)

这里提一下 constantMenus

![image-20220609182424716](https://pictures-1312013355.cos.ap-guangzhou.myqcloud.com/pictures/202206091824808.png)

到这里我们就完成了菜单栏的数据生成啦！

### 如果我不需要动态路由

通过上面的代码解析，我想你应该能够知道，我不需要后端传给我的路由，所以我只需要跟后端路由无关的 constantMenus 就行了，将有关动态路由的额外部分都剔除即可（因为这部分都是在静态路由菜单后面添加上去的）。

根据代码逻辑，我们修改 initRouter 即可

```ts
function initRouter(name: string) {
  return new Promise((resolve) => {
    usePermissionStoreHook().changeSetting([]); // 传一个空的路由数组即可
    router.addRoute({
      path: "/:pathMatch(.*)",
      redirect: "/error/404",
    });
  });
}
```

### router.addRoute

## 菜单栏布局

目前已开发垂直侧边菜单栏和顶部水平菜单栏两种模式，后续将会迭代为更复杂的综合菜单。关于这部分的基本布局设计，已经有过详细介绍，这里我们来关注代码逻辑的开发设计。

### 整体设计思路

涉及的主要文件：`src/router/utils.ts、src/store/modules/permission.ts、src/layout/components/sidebar`

![image-20211229135726709](https://pictures-1312013355.cos.ap-guangzhou.myqcloud.com/pictures/202112291357769.png)

::: warning

上面设计的最终目的是**生成菜单栏**，需要小心的是不要与路由`router`混淆了。前者是拿到属于用户可访问的菜单路由表，以该表为基础进行菜单栏渲染。后者是拿到用户可访问的路由表，构建系统页面路由。

:::

### 实现细节

#### 用户登录

首先我们在登录界面`login.vue`进行登录操作。这里并未与实际后端接口进行交互验证，只做了模拟处理

```typescript
const onLogin = (): void => {
  ...... // 一些登录相关的验证
  storageSession.setItem("info", { // 验证成功后，将后端返回的用户信息存入 sessionstorage
    username: "admin",
    accessToken: "eyJhbGciOiJIUzUxMiJ9.test"
  });
  initRouter("admin").then(() => {}); // 根据用户（角色）信息初始化菜单路由
  router.push("/"); // 登录成功后跳转页面
};
```

#### 路由获取

处理路由的工具方法都放在`src/router/utils.ts`，这里通过`initRouter`方法进行动态路由匹配并初始化菜单路由。

```typescript
// 初始化路由(传入用户角色 name)
const initRouter = (name: string) => {
  return new Promise((resolve) => {
    // 根据角色 name 拿到后端传过来的权限路由数据(info数组)
    getAsyncRoutes({ name }).then(({ info }) => {
      // 如果拿到空路由数组
      if (info.length === 0) {
        usePermissionStoreHook().changeSetting(info); // 依然调用 store 方法生成菜单相关数据
      } else {
        // 后端路由规范化 =》 路由数组扁平化 =》 添加 info 路由到 router 上
        formatFlatteningRoutes(addAsyncRoutes(info)).map(
          (v: RouteRecordRaw) => {
            // 防止重复添加路由
            if (
              router.options.routes[0].children.findIndex(
                (value) => value.path === v.path
              ) !== -1
            ) {
              return;
            } else {
              // 切记将路由 push 到 routes 后还需要使用 addRoute，这样路由才能正常跳转
              router.options.routes[0].children.push(v);
              // 路由进行升序
              ascending(router.options.routes[0].children);
              // router.hasRoute()，检查路由是否存在，不存在就加上
              if (!router.hasRoute(v?.name)) router.addRoute(v);
            }
            resolve(router); // 返回路由地址的标准化版本
          }
        );
        usePermissionStoreHook().changeSetting(info); // 调用 store 方法生成菜单相关数据
      }
      router.addRoute({
        path: "/:pathMatch(.*)", // 捕获所有路由并将其放在 $route.params.pathMatch 下
        redirect: "/error/404", // 跳转到未知路径时，重定向到 404 页面
      });
    });
  });
};
```

::: warning

这里的`initRouter`其实只是个“中介”，实际上它只是调用了一个`Promise`，来源于`src/api/routed.ts`暴露的接口，针对`Promise`的返回值做了一些处理。

:::

#### 菜单路由状态管理

接来下进入到`store`模块，有关菜单和按钮权限的状态数据都定义在`usePermissionStore`中，通过`usePermissionStoreHook`暴露出来。

```typescript
export const usePermissionStore = defineStore({
  id: "huo-permission",
  state: () => ({
    // 静态路由生成的菜单
    constantMenus,
    // 整体路由生成的菜单（静态、动态）
    wholeMenus: [],
  }),
  actions: {
    // 获取异步路由菜单
    asyncActionRoutes(routes) {
      if (this.wholeMenus.length > 0) return;
      this.wholeMenus = filterTree(
        ascending(this.constantMenus.concat(routes))
      );
    },
    async changeSetting(routes) {
      await this.asyncActionRoutes(routes);
    },
  },
});
```

#### 菜单栏渲染

这里以侧边垂直菜单栏`vertical`为例（顶部水平菜单栏菜单部分一样）。

![image-20211230094756924](https://pictures-1312013355.cos.ap-guangzhou.myqcloud.com/pictures/202112300947147.png)

#### 生成菜单栏

示例

![image-20211230144523637](https://pictures-1312013355.cos.ap-guangzhou.myqcloud.com/pictures/202112301445671.png)
